
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Memoryview Benchmarks - Pythonic Perambulations</title>
  <meta name="author" content="Jake Vanderplas">

  
  <meta name="description" content="There was recently a thread
on cython-users which caught my eye. It has to do with
memoryviews, a new
way of working with memory buffers in cython. I &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jakevdp.github.com/blog/2012/08/08/memoryview-benchmarks/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Pythonic Perambulations" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34061646-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Pythonic Perambulations</a></h1>
  
    <h2>Musings and ramblings through the world of python</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jakevdp.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Memoryview Benchmarks</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-08T18:50:00-07:00" pubdate data-updated="true">Aug 8<span>th</span>, 2012</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>There was recently a <a href="https://groups.google.com/forum/?fromgroups#!topic/cython-users/8uuxjB_wbBQ[1-25]" title="cython-users archive">thread</a>
on cython-users which caught my eye.  It has to do with
<a href="http://docs.cython.org/src/userguide/memoryviews.html">memoryviews</a>, a new
way of working with memory buffers in cython.</p>

<p>I&#8217;ve been thinking recently about how to do fast
and flexible memory buffer access in cython.  I contributed the
<a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.BallTree.html">BallTree</a>
implementation for nearest neighbors searching in
<a href="http://www.scikit-learn.org">scikit-learn</a>, and have been actively thinking
about how to make it faster and more flexible, including adding the ability
to specify distance metrics other than euclidean and minkowski.</p>

<h3>Pure python version</h3>

<p>The scenario is this: we need a way to specify a function which computes a
distance between two vectors, and can be quickly called from cython code.
In pure python, int might look something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># memview_bench_v1.py</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
</span><span class='line'>    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This looks promising.  Let&#8217;s create a function based on this which will compute
the pairwise distance between all points in a matrix (this is similar
to <a href="http://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise.pairwise_distances.html">pairwise_distances</a> in scikit-learn or
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html">pdist</a> in scipy).  The simple form of the function might look
like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># memview_bench_v1 (continued)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">euclidean_distance</span><span class="p">):</span>
</span><span class='line'>    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_dim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>      <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">D</span>
</span></code></pre></td></tr></table></div></figure>


<p>We could exploit symmetry to reduce the number of computations required, but
we&#8217;ll skip that step for now: this simple version of the function will give
us a good benchmark for comparison with alternatives below.  Using the
<code>timeit</code> magic in ipython, we can learn how fast this implementation is:</p>

<pre><code>In [1]: import numpy as np

In [2]:from memview_bench_v1 import pairwise

In [3]: X = np.random.random((500, 3))

In [4]: timeit pairwise(X)
1 loops, best of 3: 6.51 s per loop
</code></pre>

<p>Just over a second to compute 250,000 distances.  Not too bad&#8230; or is it?</p>

<h3>Cython Speedup</h3>

<p>Perhaps we can speed this up using cython declarations.  Before typed
memoryviews were added in cython 0.16, the way to quickly index numpy
arrays in cython was through the numpy specific syntax, adding type
information to each array that specifies its data type, its dimension, and
its order:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='cython'><span class='line'><span class="c"># memview_bench.pyx</span>
</span><span class='line'><span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span class='line'>
</span><span class='line'><span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span class='line'><span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">sqrt</span>
</span><span class='line'><span class="k">cimport</span> <span class="nn">cython</span>
</span><span class='line'>
</span><span class='line'><span class="c"># define a function pointer to a metric</span>
</span><span class='line'><span class="k">ctypedef</span> <span class="n">double</span> <span class="p">(</span><span class="o">*</span><span class="n">metric_ptr</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="k">cdef</span> <span class="kt">double</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">double</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">x1</span><span class="p">,</span>
</span><span class='line'>                               <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">double</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">x2</span><span class="p">):</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">tmp</span><span class="p">,</span> <span class="nf">d</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">intp_t</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">N</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">d</span> <span class="o">=</span> <span class="mf">0</span>
</span><span class='line'>    <span class="n">N</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
</span><span class='line'>    <span class="c"># assume x2 has the same shape as x1.  This could be dangerous!</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
</span><span class='line'>        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>        <span class="n">d</span> <span class="o">+=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">tmp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">double</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">X</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span>
</span><span class='line'>             <span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;euclidean&#39;</span><span class="p">):</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">metric_ptr</span> <span class="nf">dist_func</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;euclidean&#39;</span><span class="p">:</span>
</span><span class='line'>        <span class="n">dist_func</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">euclidean_distance</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unrecognized metric&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">intp_t</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">j</span><span class="p">,</span> <span class="nf">n_samples</span>
</span><span class='line'>    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">ndarray</span>[<span class="nf">double</span><span class="p">,</span> <span class="nf">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span>
</span><span class='line'>                                                            <span class="n">n_samples</span><span class="p">))</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_func</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">D</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that we&#8217;re essentially running the same code, except we have added
type identifiers to speed up function calls and loops.  The <code>mode='c'</code>
argument in the <code>np.ndarray</code> type says that the array is contiguous in
memory, and C-ordered.</p>

<p>For reference, this can be compiled in-place by running
<code>python setup.py build_ext --inplace</code> with the following
setup.py file:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># setup.py</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">os</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">numpy</span>
</span><span class='line'>
</span><span class='line'><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">distutils.extension</span> <span class="kn">import</span> <span class="n">Extension</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">Cython.Distutils</span> <span class="kn">import</span> <span class="n">build_ext</span>
</span><span class='line'>
</span><span class='line'><span class="n">module</span> <span class="o">=</span> <span class="s">&#39;memview_bench_v2&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">setup</span><span class="p">(</span><span class="n">cmdclass</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;build_ext&#39;</span><span class="p">:</span> <span class="n">build_ext</span><span class="p">},</span>
</span><span class='line'>      <span class="n">name</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
</span><span class='line'>      <span class="n">version</span><span class="o">=</span><span class="s">&#39;1.0&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">Extension</span><span class="p">(</span><span class="n">module</span><span class="p">,</span>
</span><span class='line'>                             <span class="p">[</span><span class="n">module</span> <span class="o">+</span> <span class="s">&quot;.pyx&quot;</span><span class="p">])],</span>
</span><span class='line'>      <span class="n">include_dirs</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">get_include</span><span class="p">(),</span>
</span><span class='line'>                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">get_include</span><span class="p">(),</span> <span class="s">&#39;numpy&#39;</span><span class="p">)]</span>
</span><span class='line'>      <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>We&#8217;ll time the resulting function on the same sized array as we did previously:</p>

<pre><code>In [1]: import numpy as np

In [2]: from memview_bench_v2 import pairwise

In [3]: X = np.random.random((500, 3))

In [4]: timeit pairwise(X)
1 loops, best of 3: 668 ms per loop
</code></pre>

<p>That&#8217;s a factor of 10 speedup over the pure python version!  It turns out,
though, that we can do better.  In particular, the slicing operation when
we call <code>X[i]</code> and <code>X[j]</code> must generate a new numpy array each time, which
leads to a lot of python overhead in reference counting, etc.  This is the
reason that the cython team introduced typed memoryviews in cython v0.16.</p>

<h3>Typed Memoryviews</h3>

<p>The equivalent of the above code using typed memoryviews looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='cython'><span class='line'><span class="c"># memview_bench_v3.pyx</span>
</span><span class='line'><span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span class='line'>
</span><span class='line'><span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span class='line'><span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">sqrt</span>
</span><span class='line'><span class="k">cimport</span> <span class="nn">cython</span>
</span><span class='line'>
</span><span class='line'><span class="c"># define a function pointer to a metric</span>
</span><span class='line'><span class="k">ctypedef</span> <span class="n">double</span> <span class="p">(</span><span class="o">*</span><span class="n">metric_ptr</span><span class="p">)(</span><span class="n">double</span><span class="p">[::</span><span class="mf">1</span><span class="p">],</span> <span class="n">double</span><span class="p">[::</span><span class="mf">1</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="k">cdef</span> <span class="kt">double</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">double</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">x1</span><span class="p">,</span>
</span><span class='line'>                               <span class="n">double</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">x2</span><span class="p">):</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">tmp</span><span class="p">,</span> <span class="nf">d</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">intp_t</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">N</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">d</span> <span class="o">=</span> <span class="mf">0</span>
</span><span class='line'>    <span class="n">N</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
</span><span class='line'>    <span class="c"># assume x2 has the same shape as x1.  This could be dangerous!</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
</span><span class='line'>        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>        <span class="n">d</span> <span class="o">+=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">tmp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="n">double</span><span class="p">[:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">X</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span>
</span><span class='line'>             <span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;euclidean&#39;</span><span class="p">):</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">metric_ptr</span> <span class="nf">dist_func</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;euclidean&#39;</span><span class="p">:</span>
</span><span class='line'>        <span class="n">dist_func</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">euclidean_distance</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unrecognized metric&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">intp_t</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">j</span><span class="p">,</span> <span class="nf">n_samples</span>
</span><span class='line'>    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span>[<span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_func</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">D</span>
</span></code></pre></td></tr></table></div></figure>


<p>The only change is that instead of using the <code>np.ndarray[...]</code> type specifier,
we use the typed memoryview <code>double[:, ::1]</code> specifier.  The <code>::1</code> in the
second position means that we are passing a two-dimensional array, which
is contiguous and C-ordered.  We time the results and see the following:</p>

<pre><code>In [1]: import numpy as np

In [2]: from memview_bench_v3 import pairwise

In [3]: X = np.random.random((500, 3))

In [4]: timeit pairwise(X)
10 loops, best of 3: 22 ms per loop
</code></pre>

<p>This gives another factor of 30 improvement over the previous version, simply
by switching to typed memoryviews rather than the numpy interface.  Still,
our function is creating memoryview objects each time we slice the array.  We
can determine how much overhead this is generating by using raw C pointers
instead.  It&#8217;s not as clean, but it should be very fast:</p>

<h3>Raw Pointers</h3>

<p>The fundamental benchmark for this sort of operation should be working
directly with the pointers themselves.  While this is not a very &#8220;pythonic&#8221;
way of doing things, it does lead to very fast code, as we will see:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='cython'><span class='line'><span class="c"># memview_bench_v4.pyx</span>
</span><span class='line'><span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span class='line'>
</span><span class='line'><span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span class='line'><span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">sqrt</span>
</span><span class='line'><span class="k">cimport</span> <span class="nn">cython</span>
</span><span class='line'>
</span><span class='line'><span class="c"># define a function pointer to a metric</span>
</span><span class='line'><span class="k">ctypedef</span> <span class="n">double</span> <span class="p">(</span><span class="o">*</span><span class="n">metric_ptr</span><span class="p">)(</span><span class="n">double</span><span class="o">*</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="k">cdef</span> <span class="kt">double</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">double</span><span class="o">*</span> <span class="n">x1</span><span class="p">,</span>
</span><span class='line'>                               <span class="n">double</span><span class="o">*</span> <span class="n">x2</span><span class="p">,</span>
</span><span class='line'>                               <span class="nb">int</span> <span class="n">N</span><span class="p">):</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">tmp</span><span class="p">,</span> <span class="nf">d</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">intp_t</span> <span class="nf">i</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">d</span> <span class="o">=</span> <span class="mf">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
</span><span class='line'>        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>        <span class="n">d</span> <span class="o">+=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">tmp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="n">double</span><span class="p">[:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">X</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span>
</span><span class='line'>             <span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;euclidean&#39;</span><span class="p">):</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">metric_ptr</span> <span class="nf">dist_func</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;euclidean&#39;</span><span class="p">:</span>
</span><span class='line'>        <span class="n">dist_func</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">euclidean_distance</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unrecognized metric&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">intp_t</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">j</span><span class="p">,</span> <span class="nf">n_samples</span><span class="p">,</span> <span class="nf">n_dim</span>
</span><span class='line'>    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
</span><span class='line'>    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span>[<span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span>* <span class="nf">Dptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">D</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">]</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span>* <span class="nf">Xptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">X</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>            <span class="n">Dptr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">n_samples</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_func</span><span class="p">(</span><span class="n">Xptr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n_dim</span><span class="p">,</span>
</span><span class='line'>                                                <span class="n">Xptr</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">n_dim</span><span class="p">,</span>
</span><span class='line'>                                                <span class="n">n_dim</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">D</span>
</span></code></pre></td></tr></table></div></figure>


<p>Instead of passing around slices of arrays, we&#8217;ve accessed the raw memory
buffer using C pointer syntax.  This is not as easy to read, and can lead
to <code>glibc</code> errors or segmentation faults if we&#8217;re not careful.  Testing
this implementation, we find that it&#8217;s comaprably very fast:</p>

<pre><code>In [1]: import numpy as np

In [2]: from memview_bench_v4 import pairwise

In [3]: X = np.random.random((500, 3))

In [4]: timeit pairwise(X)
100 loops, best of 3: 2.47 ms per loop
</code></pre>

<p>This is another factor of 10 faster than the memoryview benchmark above!
Essentially, what this is telling us is that creating a memoryview slice
takes about 0.02 / 500,000 = 40 nanoseconds on our machine.  This is extremely
fast, but because we&#8217;re performing this operation half a million times, it&#8217;s
significant compared to the rest of our computation.  If our vectors were,
say, length 1000, this cost may not be a significant difference.</p>

<p>So what are we left with?  Do we need to use raw pointers in all circumstances
when working with collections of small vectors?  Perhaps not.</p>

<h3>A Faster Implementation with Memoryviews</h3>

<p>The creation of memoryview slices, though extremely fast, is causing a problem
simply because we&#8217;re creating so many slices.  Here is an alternative which
uses no raw pointers, but is much more competetive:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='cython'><span class='line'><span class="c"># memview_bench_v5.pyx</span>
</span><span class='line'><span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span class='line'>
</span><span class='line'><span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span class='line'><span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">sqrt</span>
</span><span class='line'><span class="k">cimport</span> <span class="nn">cython</span>
</span><span class='line'>
</span><span class='line'><span class="c"># define a function pointer to a metric</span>
</span><span class='line'><span class="k">ctypedef</span> <span class="n">double</span> <span class="p">(</span><span class="o">*</span><span class="n">metric_ptr</span><span class="p">)(</span><span class="n">double</span><span class="p">[:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">intp_t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp_t</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="k">cdef</span> <span class="kt">double</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">double</span><span class="p">[:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">X</span><span class="p">,</span>
</span><span class='line'>                               <span class="n">np</span><span class="o">.</span><span class="n">intp_t</span> <span class="n">i1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp_t</span> <span class="n">i2</span><span class="p">):</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">tmp</span><span class="p">,</span> <span class="nf">d</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">intp_t</span> <span class="nf">j</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">d</span> <span class="o">=</span> <span class="mf">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">1</span><span class="p">]):</span>
</span><span class='line'>        <span class="n">tmp</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
</span><span class='line'>        <span class="n">d</span> <span class="o">+=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">tmp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="n">double</span><span class="p">[:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">X</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span>
</span><span class='line'>             <span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;euclidean&#39;</span><span class="p">):</span>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">metric_ptr</span> <span class="nf">dist_func</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;euclidean&#39;</span><span class="p">:</span>
</span><span class='line'>        <span class="n">dist_func</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">euclidean_distance</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unrecognized metric&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">np</span>.<span class="kt">intp_t</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">j</span><span class="p">,</span> <span class="nf">n_samples</span><span class="p">,</span> <span class="nf">n_dim</span>
</span><span class='line'>    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
</span><span class='line'>    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">cdef</span> <span class="kt">double</span>[<span class="p">:,</span> <span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
</span><span class='line'>            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">D</span>
</span></code></pre></td></tr></table></div></figure>


<p>Timing this implementation we find the following:</p>

<pre><code>In [1]: import numpy as np

In [2]: from memview_bench_v5 import pairwise

In [3]: X = np.random.random((500, 3))

In [4]: timeit pairwise(X)
100 loops, best of 3: 2.45 ms per loop
</code></pre>

<p>Just as fast as using raw pointers, but much more clean.</p>

<h3>Summary</h3>

<p>Here are our timing results summarized:</p>

<ul>
<li><strong>Python + numpy</strong>: 6510 ms</li>
<li><strong>Cython + numpy</strong>: 668 ms</li>
<li><strong>Cython + memviews (slicing)</strong>: 22 ms</li>
<li><strong>Cython + raw pointers</strong>: 2.47 ms</li>
<li><strong>Cython + memviews (no slicing)</strong>: 2.45 ms</li>
</ul>


<p>So what have we learned here?  First of all, typed memoryviews are fast.
Blazing fast.  If used correctly, they can be comparable to raw pointers,
but are much cleaner easier to debug.  For example, in the last
version, if we ran into a memory error we could simply turn on bounds-checking
and quickly find the source of the problem.  Slicing with memoryviews is
also fast, but should be used carefully if your operation time on each slice
is compararable to the cost of building the slice.</p>

<p>The moral of the story?  <em>Use typed memoryviews.</em>  It will lead to fast cython
code which is cleaner, more readable, and more easily debuggable than any other
alternative.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Jake Vanderplas</span></span>

      








  


<time datetime="2012-08-08T18:50:00-07:00" pubdate data-updated="true">Aug 8<span>th</span>, 2012</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://jakevdp.github.com/blog/2012/08/08/memoryview-benchmarks/" data-via="" data-counturl="http://jakevdp.github.com/blog/2012/08/08/memoryview-benchmarks/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/08/08/memoryview-benchmarks/">Memoryview Benchmarks</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/jakevdp">@jakevdp</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jakevdp',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Jake Vanderplas -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'pythonicperambulations';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://jakevdp.github.com/blog/2012/08/08/memoryview-benchmarks/';
        var disqus_url = 'http://jakevdp.github.com/blog/2012/08/08/memoryview-benchmarks/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
